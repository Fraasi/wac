#!/usr/bin/env bash
# shellcheck source=/dev/null disable=
#
# script for querying wolfram-alpha api from command line
#

version="1.0.0"

# if WOLFRAM_APP_ID is empty & ~/.config/wac/config is readable
if [[ -z "$WOLFRAM_APP_ID" && -r "$HOME"/.config/wac/config ]]; then
  source "$HOME"/.config/wac/config
fi

# check for dependencies
dependencies=('curl' 'jq')
for dep in "${dependencies[@]}"; do
  if ! command -v "$dep" >/dev/null 2>&1; then
    printf "%s has a dependency of %s which was not found in path\nexiting..." "$(basename "$0")" "$dep"
    exit 1
  fi
done

# check if running in wsl for start program
if command -v wsl.exe >/dev/null 2>&1; then
  start="explorer.exe"
else
  start="xdg-open"
fi

function usage() {
  printf "
Usage:
  %s [options] <your query>

  Options:
  -d    debug (with -f, dump json to result.json)
  -f    full api mode (default)
  -h    show this help
  -s    spoken mode
  -r    result mode
  -v    show version
  -w    query the web interface
  " "$(basename "$0")"
}

function main() {

  local mode="query"
  local app_id="$WOLFRAM_APP_ID"
  local base_url="https://api.wolframalpha.com/v2"
  local debug=false

  while getopts "dfhsrvw" OPTNAME; do
    case "$OPTNAME" in
    d)
      debug=true
      ;;
    f)
      mode="query"
      ;;
    h)
      usage
      exit 0
      ;;
    s)
      mode="spoken"
      ;;
    r)
      mode="result"
      ;;
    v)
      printf "v%s" "$version"
      exit 0
      ;;
    w)
      shift
      "$start" "https://www.wolframalpha.com/input?i=$*"
      exit 0
      ;;
    *)
      usage
      exit 1
      ;;
    esac
  done
  shift $((OPTIND - 1))

  local result
  result=$(curl --silent \
    --data "output=json" \
    --data "reinterpret=true" \
    --data "appid=$app_id" \
    --data-urlencode "input=$*" \
    "$base_url/$mode")

  if [[ "$debug" == true ]]; then
    printf "%s" "$result" >result.json
  fi
  # TODO: catch jq errors if no results
  #echo "$result"
jq --raw-output '
def colors:
  {
    "black": "\u001b[30m",
    "red": "\u001b[31m",
    "green": "\u001b[32m",
    "yellow": "\u001b[33m",
    "blue": "\u001b[34m",
    "magenta": "\u001b[35m",
    "cyan": "\u001b[36m",
    "white": "\u001b[37m",
    "reset": "\u001b[0m",
  };

# if string, return it
if type == "string" then .
# if no success, return error
elif .[].success == false then
    "success: " + (.[].success | tostring),
    "error: " + (.[].error | tostring)
# else parse json
else
    # if there is didyoumeans
    if .[].didyoumeans != null then
        "didyoumeans",
      "inputstring:", "\t" + (.[].inputstring | tostring),
      "didyoumeans:", "\t" + (.[].didyoumeans[].val | tostring)
    else
      .[].pods[] | (.title + ":", "\t" + .subpods[].plaintext, "")
    end
end
' <<< "$result"
}

main "$@"
